# 2024-09-22_2
The project's name is `ArtificalThought` or `athought` for short. It is a streamlit application that allows for "easy" development of large language model demos wrapped in a chat bot interface.

I say "easy" and not easy because the layout of the project is still somewhat complicated. I need assistance simplifying it.

# AI Task
Simplify / refactor the structure around agents for easier development.


## Files
- app.py
- src
    - app
        - chat_interface.py
    - agents
        - agent-handler.py
        - agents.py
        - base_agent.py
        - prompt.py

## Background on Agents

The agent system in this project is designed to be flexible and extensible, allowing for the creation of various types of AI agents with different capabilities. Here's an overview of the key components:

1. AgentHandler (agent_handler.py):
   - Manages the creation and switching of different agent types.
   - Loads agent configurations from a YAML file.
   - Provides methods to change the active agent and its model.
   - Uses a mapping (AGENT_TYPE_MAP) to associate agent types with their respective classes.

2. BaseAgent (base_agent.py):
   - An abstract base class that defines the interface for all agents.
   - Requires implementation of `__init__`, `generate_response`, and `_build_llm` methods.

3. ChainableAgent (agents.py):
   - A base class for agents that use multiple LLM inferences in a linear sequence.
   - Implements core functionality like initializing the agent, building the LLM, and running chains.
   - Uses a decorator (`@register_chain`) to easily add new chains to the agent.
   - Manages an ordered dictionary of chains that are executed sequentially.

4. Specific Agent Implementations (agents.py):
   - SimpleAgent: A basic agent with a single chain for generating responses.
   - IntrospectiveAgent: An advanced agent that performs introspection before generating a response.
   - RoleAgent: An agent that can dynamically update its role based on the conversation context.

5. Chain Structure:
   - Each chain typically consists of a prompt template, an LLM, and a parser.
   - Chains are built using the LangChain library, leveraging components like ChatPromptTemplate, RunnablePassthrough, and StrOutputParser.

6. Memory Handling:
   - Agents have access to both internal memory and session state memory.
   - The `fetch_memory` method allows retrieval of conversation history.

7. Integration with Streamlit:
   - Agents are designed to work with Streamlit's UI components, particularly for streaming responses.
   - The `StreamHandler` is used to provide real-time updates to the Streamlit UI during response generation.

8. Prompt Management:
   - Prompts are centralized in the `prompt.py` file, allowing for easy management and reuse across different agent types.

9. Model Flexibility:
   - The system is designed to work primarily with OpenAI's models but has the flexibility to add support for other providers.

10. Developer Tools:
    - Includes methods like `debug_prompt` for easier development and debugging of agent behavior.

This agent system allows for easy creation of new agent types by extending the ChainableAgent class and defining specific chains. The use of decorators and ordered execution of chains provides a clear and flexible structure for implementing complex reasoning processes in AI agents.


## How Agents are Used in Chat

The chat interface interacts with agents through the `AgentHandler` class, which manages agent creation and selection. Here's an overview of how agents are used in the chat system:

1. Agent Initialization:
   - The `AgentHandler` is initialized in `src/app/initialization.py` with a configuration file path.
   - It loads agent parameters from a YAML file and creates the initial active agent.

2. Agent Selection:
   - The `AgentHandler` maintains a list of available agent titles.
   - Users can switch between agents using the UI (likely through a menu option).
   - When a new agent is selected, `AgentHandler` creates a new instance of the appropriate agent class.

3. Model Changes:
   - The `change_model` method in `AgentHandler` allows changing the model for the active agent.
   - This creates a new agent instance with the updated model while maintaining the same agent type.

4. Chat Flow:
   - The `handle_chat` function in `chat_interface.py` manages the main chat loop.
   - When a query is received:
     a. References are added to the query if file content is available.
     b. The query is displayed in the UI.
     c. The active agent generates a response.
     d. The response is displayed in the UI.
     e. Both query and response are added to the chat memory.

5. Agent Response Generation:
   - The `handle_response` function calls `agent.generate_response(query, chat_container)`.
   - This method is implemented in the `ChainableAgent` class and executes the agent's chain(s).
   - The `StreamHandler` is used to provide real-time updates to the Streamlit UI during response generation.

6. Memory Handling:
   - The chat interface adds both user queries and agent responses to the `memory_cache`.
   - This memory is used to provide context for future interactions.

7. Special Commands:
   - The chat interface recognizes special commands, such as '/' to toggle the menu.

8. File References:
   - The `add_references_to_query` function can add file content to the query if available.
   - This allows agents to work with external data or code snippets.

9. Agent Types:
   - Different agent types (SimpleAgent, IntrospectiveAgent, RoleAgent) can be used interchangeably.
   - Each agent type may have different chain structures or behaviors, but they all implement the same interface.

10. Configuration:
    - Agent parameters are loaded from a YAML file, allowing for easy configuration of different agent types and models.

This structure allows for a flexible chat system where different types of agents can be easily swapped or configured, while maintaining a consistent interface for the chat application. The separation of agent logic from the chat interface allows for easy extension and modification of agent behaviors without affecting the core chat functionality.

## Suggested Simplifications   ```

1. Implement Agent Registration System:
   - Create a new file `agent_registry.py` in the `src/agents` directory.
   - Implement a decorator for registering agents and a registry class:

   ```python
   # agent_registry.py
   from typing import Type, Dict
   from src.agents.base_agent import BaseAgent

   class AgentRegistry:
       _registry: Dict[str, Type[BaseAgent]] = {}

       @classmethod
       def register(cls, agent_type: str):
           def decorator(agent_class: Type[BaseAgent]):
               cls._registry[agent_type] = agent_class
               return agent_class
           return decorator

       @classmethod
       def get_agent_class(cls, agent_type: str) -> Type[BaseAgent]:
           return cls._registry.get(agent_type)

       @classmethod
       def list_agent_types(cls):
           return list(cls._registry.keys())

   def register_agent(agent_type: str):
       return AgentRegistry.register(agent_type)
   ```

   - Update the existing agent classes to use the registration decorator:

   ```python
   # agents.py
   from src.agents.intermediate_agents import ChainableAgent, CustomAgent
   from src.agents.agent_registry import register_agent

   @register_agent("simple")
   class SimpleAgent(ChainableAgent):
       # ... existing implementation ...

   @register_agent("introspective")
   class IntrospectiveAgent(ChainableAgent):
       # ... existing implementation ...

   @register_agent("role")
   class RoleAgent(ChainableAgent):
       # ... existing implementation ...
   ```

   - Update the `AgentHandler` to use the registry:

   ```python
   # agent_handler.py
   from src.agents.agent_registry import AgentRegistry

   class AgentHandler:
       def _create_new_agent(self, title: str, model: str = None) -> Optional[BaseAgent]:
           if title not in self._agent_params:
               st.error(f"No agent configuration found for: {title}")
               return None

           kwargs = self._agent_params[title]
           if isinstance(model, str):
               kwargs['model'] = model

           agent_type = kwargs.get('type', 'simple')
           agent_class = AgentRegistry.get_agent_class(agent_type)
           if agent_class is None:
               raise ValueError(f"Agent type {agent_type} is not supported.")

           return agent_class(title, **kwargs)
   ```

These changes will create a more flexible and extensible agent system. The intermediate agent classes provide a clear structure for different types of agents, while the registration system allows for easy addition of new agent types without modifying the `AgentHandler` or other core components.
