# 2024-09-20
The project's name is `ArtificalThought` or `athought` for short. It is a streamlit application that allows for "easy" development of large language model demos wrapped in a chat bot interface.

I say "easy" and not easy because the layout of the project is still somewhat complicated. I need assistance simplifying it.

# AI Task
## Files
- src
    - agents
        - agent-handler.py
        - agents.py
        - base_agent.py
        - prompt.py


## NOTES ON AGENTS

1. Agent Structure:
   - The `agents.py` file defines a hierarchy of agent classes, with `ChainableAgent` as the base class.
   - All agents inherit from `BaseAgent` (defined in `base_agent.py`).

2. ChainableAgent:
   - Acts as a general base class for agents that use multiple LLM inferences in a linear sequence.
   - Implements core functionality like initializing the agent, building the LLM, and running chains.
   - Uses the `generate_response` method as the main external interface, which calls the internal `_run_chains` method.
   - Supports adding chains, fetching memory, and debugging prompts.

3. Agent Types:
   - SimpleAgent: A basic agent that uses a single chain for generating responses.
   - IntrospectiveAgent: An advanced agent that performs introspection before generating a response.
   - RoleAgent: An agent that can dynamically update its role based on the conversation context.

4. Chain Structure:
   - Agents use the concept of "chains" to process queries and generate responses.
   - Chains typically involve a prompt template, an LLM, and a parser.
   - The `_build_chain` method in each agent class defines the specific chain structure.

5. Memory Handling:
   - Agents use both internal memory and session state memory.
   - The `fetch_memory` method allows retrieval of conversation history.

6. Prompt Management:
   - Prompts are imported from a separate `prompt.py` file, allowing for centralized prompt management.

7. Streaming Support:
   - Agents support streaming responses using the `StreamHandler` for real-time interaction.

8. Flexibility:
   - The modular design allows for easy addition of new agent types by extending the `ChainableAgent` class.

9. LLM Integration:
   - Currently supports OpenAI's ChatGPT models, with the flexibility to add more providers.

10. Developer Tools:
    - Includes methods like `debug_prompt` for easier development and debugging.

Overall, the agent system is designed to be flexible and extensible, allowing for the creation of various types of agents with different capabilities and behaviors. The chainable structure provides a clear way to implement complex multi-step reasoning processes.

## NOTES ON AGENT DECORATORS

1. Decorator Function:
   - A `register_chain` decorator is defined at the module level.
   - This decorator is used to mark methods that build chains in agent classes.

2. Decorator Implementation:
   ```python
   def register_chain(func):
       @wraps(func)
       def wrapper(self, *args, **kwargs):
           chain = func(self, *args, **kwargs)
           self._add_chain(chain)
           return chain
       wrapper._is_chain = True
       return wrapper
   ```
   - Uses `@wraps(func)` to preserve the original function's metadata.
   - Calls the original function to build the chain.
   - Automatically adds the built chain to the agent's chains list using `self._add_chain(chain)`.
   - Marks the wrapper function with `_is_chain = True` for later identification.

3. Usage in Agent Classes:
   - The `@register_chain` decorator is applied to methods that build chains in each agent class.
   - Example:
     ```python
     class SimpleAgent(ChainableAgent):
         @register_chain
         def _build_chain(self):
             # Chain building logic
     ```

4. Chain Initialization:
   - The `ChainableAgent` base class includes an `_initialize_chains` method:
     ```python
     def _initialize_chains(self):
         for method_name in dir(self):
             method = getattr(self, method_name)
             if callable(method) and hasattr(method, '_is_chain'):
                 method()
     ```
   - This method is called in the `__init__` of `ChainableAgent`.
   - It automatically calls all methods marked with `@register_chain` during object initialization.

5. Benefits:
   - Reduces boilerplate code in agent classes.
   - Automatically manages the addition of chains to the agent's chain list.
   - Provides a clear visual indicator of which methods are responsible for building chains.
   - Allows for easy addition of new chains to existing agent classes.

6. Potential Improvements:
   - Consider adding parameters to the decorator for more fine-grained control (e.g., chain order, conditional execution).
   - Implement error handling within the decorator to manage exceptions during chain building.
   - Add logging or debugging capabilities within the decorator for easier troubleshooting.

7. Impact on Agent Structure:
   - The decorator approach simplifies the agent class definitions.
   - It enforces a consistent pattern for adding chains across different agent types.
   - Makes it easier to maintain and extend the agent system by providing a clear structure for adding new functionality.

Overall, the current decorator implementation provides a clean and efficient way to manage chain building in the agent system. It significantly reduces code duplication and improves the readability and maintainability of the agent classes.

## IMPROVEMENTS TO AGENT DECORATORS

We have implemented improvements to ensure that chains are registered in order from top to bottom. Here are the key changes and their implications:

1. OrderedDict for Chain Storage:
   - Changed `self.chains` from a list to an `OrderedDict` in the `ChainableAgent` class.
   - This preserves the order in which chains are added, ensuring they are executed in the same order.

2. Updated Decorator Implementation:
   ```python
   def register_chain(func):
       @wraps(func)
       def wrapper(self, *args, **kwargs):
           chain = func(self, *args, **kwargs)
           self._add_chain(func.__name__, chain)
           return chain
       wrapper._is_chain = True
       return wrapper
   ```
   - Now uses the function name as the key when adding the chain to the OrderedDict.

3. Modified Chain Addition:
   ```python
   def _add_chain(self, name, chain):
       self.chains[name] = chain
   ```
   - Chains are now added to the OrderedDict with their method names as keys.

4. Updated Chain Execution:
   ```python
   def _run_chains(self, query, container):
       result = None
       for chain_name, chain in self.chains.items():
           result = chain.invoke({'role': self.role, 'query': query}, {'callbacks': [StreamHandler(container)]})
       return result 
   ```
   - Chains are executed in the order they were added, preserving the top-to-bottom definition order in the agent classes.

5. Chain Initialization:
   - The `_initialize_chains` method now looks for methods starting with `_build_` (excluding `_build_llm`).
   - This allows for more flexibility in naming chain-building methods while maintaining order.

Benefits of This Approach:
1. Predictable Execution Order: Chains are executed in the same order they are defined in the agent classes.
2. Flexibility: Developers can control the order of chain execution simply by changing the order of method definitions.
3. Readability: The chain execution order is clear from the class structure, improving code comprehension.
4. Maintainability: Adding or removing chains is straightforward and doesn't require modifying execution logic.

Potential Future Improvements:
1. Add a method to view the current chain order for debugging purposes.
2. Implement a way to dynamically reorder chains if needed during runtime.
3. Add error handling to manage exceptions during chain building and execution.

This implementation provides a balance between simplicity and control, allowing for ordered chain execution without introducing complex ordering parameters.
